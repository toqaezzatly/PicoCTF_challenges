# Heap 0
**Category:** Binary Exploitation (Heap Overflow)
**Technique:** Variable Overwriting / Bounds Violation

## 1. The Theory: Understanding the Battlefield
Before solving, we must understand *where* we are hacking and *why* the hack works.

### A. Stack vs. Heap
The computer's RAM is divided into different regions. This challenge takes place on the **Heap**, not the Stack.

*   **The Stack (The Ordered Pile):**
    *   Used for temporary variables inside functions.
    *   Managed automatically by the CPU (Last-In, First-Out).
    *   Grows "Down" (High memory addresses $\to$ Low memory addresses).
*   **The Heap (The Open Warehouse):**
    *   Used for long-term storage or large data.
    *   Managed manually by the programmer (using `malloc` to ask for space).
    *   Grows **"Up"** (Low memory addresses $\to$ High memory addresses).
    *   **Relevance:** In the Heap, variables are often placed right next to each other in increasing order.

### B. The Memory Layout (The "Strip of Paper")
Memory is not a collection of separate buckets with walls between them. It is one continuous strip of paper with numbered squares (addresses).

In this challenge, the Operating System assigned two adjacent blocks:
1.  **`input_data` (Your Buffer):** Starts at address `...2b0`. Size: 32 Bytes.
2.  **`safe_var` (The Lock):** Starts at address `...2d0`. Contains the text "bico".

Because the Heap grows **UP**, `safe_var` sits physically immediately after `input_data`.

### C. The Vulnerability: Missing "Guards"
The program uses a C function (likely `scanf` or `gets`) to take your input.
*   **In modern languages (Python/Java):** A "Guard" checks if you write past the end of your assigned 32 bytes and crashes the program if you do (Error).
*   **In C (This Challenge):** There are **no guards**. The program blindly trusts the user. If you keep typing past the 32nd character, the "cursor" simply moves into the next memory block and keeps writing.

---

## 2. Reconnaissance & Math

When we connect to the server, it prints the Heap State:

```text
[*]   0x571e42c5c2b0  ->   pico   (Our Buffer)
[*]   0x571e42c5c2d0  ->   bico   (The Target)
```

We calculate the distance (offset) between them:
*   `0x2d0` - `0x2b0` = `0x20` (Hexadecimal)
*   `0x20` converted to Decimal = **32 Bytes**.

**Conclusion:** We have exactly 32 bytes of space before we hit the "Safe Variable."

---

## 3. The Logic of the "Lock"

You asked: *"Are we making a pointer point to the flag?"*
**Answer:** No. We are breaking a logical condition.

The source code logic looks like this:
```c
// The Lock
if (strcmp(safe_var, "bico") != 0) {
    // If safe_var is NOT "bico", print the flag
    print_flag();
}
```
The program assumes that since it never gave you a menu option to edit `safe_var`, it will stay "bico" forever.

**Our Goal:** Overwrite `safe_var` so it is anything **except** "bico". This makes the condition `TRUE`, and the program gives us the flag.

---

## 4. The Exploit Strategy

1.  **Write to Buffer:** We will write data into the first block (`input_data`).
2.  **Overflow:** We will write **more than 32 characters**.
3.  **Corruption:** The first 32 characters fill our box. The 33rd character (and beyond) spills over the edge and overwrites the "b" in "bico".

**Visualizing the Overwrite:**
*   **Normal State:**
    `[ ... 32 bytes of space ... ] [ b i c o ]`
*   **Attack State (Sending 50 'A's):**
    `[ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ] [ A A A A A A ... ]`

The "Lock" variable now contains "AAAA..." instead of "bico". The lock is broken.

---

## 5. Execution Steps

1.  **Connect:**
    ```bash
    nc tethys.picoctf.net 52336
    ```

2.  **Select Write Option:**
    Type `2` and press Enter.

3.  **Send Payload:**
    Type a string longer than 32 characters. 50 'A's is a safe bet.
    ```text
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    ```

4.  **Verify (Optional):**
    If you select option `1` (Print Heap) now, you will see the second address no longer says "bico". It is corrupted.

5.  **Get Flag:**
    Type `4` and press Enter. The program checks the variable, sees it has changed, and prints the flag.

**Flag:** `picoCTF{my_first_heap_overflow_...}` (Your specific flag will vary).

---

## 6. Summary of Lessons
*   **Buffer Overflow:** Writing more data than a memory block can hold.
*   **Heap:** A memory region where data stays until manually freed, growing upwards.
*   **Bounds Checking:** The lack of this check in C allows us to overwrite neighboring variables.
*   **Control Flow:** We didn't execute code; we changed a variable that controls the program's logic.
