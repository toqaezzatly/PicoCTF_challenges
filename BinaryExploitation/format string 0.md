#  PicoCTF - Format String 0

## Challenge Overview
*   **Author:** Cheng Zhang
*   **Category:** Binary Exploitation
*   **Difficulty:** Easy
*   **Goal:** Use format string vulnerabilities to trigger a segmentation fault, which activates a custom signal handler that prints the flag.

## 1. Analysis
Looking at the source code (`format-string-0.c`), we see two distinct stages where we provide input that is passed directly into `printf()`.

### Stage 1: Serving Patrick
The code defines `BUFSIZE` as 32. To move to the next stage, we must satisfy this condition:
```c
int count = printf(choice1);
if (count > 2 * BUFSIZE) {
    serve_bob();
}
```
*   `2 * BUFSIZE` is **64**.
*   The variable `count` stores how many characters `printf` actually printed to the screen.
*   We need to make `printf` output more than 64 characters using a string that fits in the 32-byte buffer.

### Stage 2: Serving Bob
Once we reach Bob, the code simply does this:
```c
printf(choice2);
```
There is no length check here. However, the program has a signal handler (`sigsegv_handler`) that prints the flag if the program crashes with a **Segmentation Fault**.

---

## 2. Exploitation Strategy

### Step 1: The Padding Attack (`%114d`)
We need a menu item that causes `printf` to output a lot of characters. 
*   **Input:** `Gr%114d_Cheese`
*   **Why it works:** The `%114d` tells `printf` to print an integer and pad it with spaces so that it takes up **114 characters** of space. Even though we didn't provide an integer argument, `printf` will just grab whatever value is next on the stack. Because 114 is greater than 64, the condition `count > 64` becomes true, and we move to Bob.

### Step 2: The Null Pointer Dereference (`%s`)
We need to make the program crash.
*   **Input:** `Cla%sic_Che%s%steak`
*   **Why it works:** The `%s` specifier tells `printf` to "Go to the memory address currently on the stack and print the string found there." 
*   Since the program does not provide a memory address as an argument, `printf` looks at "garbage" data on the stack. Eventually, it will try to read from an address that is restricted or doesn't exist (like `0x0`). This causes a **Segmentation Fault (SIGSEGV)**.

---

## 3. Execution
1.  **Connect** to the instance: `nc rhea.picoctf.net [PORT]`
2.  **First prompt:** Select `Gr%114d_Cheese`. The screen fills with empty space, and Patrick is satisfied.
3.  **Second prompt:** Select `Cla%sic_Che%s%steak`. The program attempts to read a string from an invalid address and crashes.
4.  **Result:** The signal handler catches the crash and prints the flag.

## 4. Conclusion
The vulnerability exists because the program uses `printf(input)` instead of `printf("%s", input)`. This allows the user to inject their own format specifiers to control the output length (`%d` with width) or force the program to read from unauthorized memory locations (`%s`), leading to a crash.

**Flag:** `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_xxxxxxxx}`
