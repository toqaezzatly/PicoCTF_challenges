# **Challenge Writeup: Input Injection 2 (Heap Overflow)**

### **1. Challenge Overview**
*   **Target:** A C program that allocates memory on the **Heap** for a username and a shell command.
*   **Goal:** Overwrite the hardcoded command (`/bin/pwd`) with a custom command (`sh`) to gain full control of the server.
*   **Vulnerability:** Unbounded input using `scanf("%s")`.

---

### **2. Source Code Analysis**
```c
char* username = malloc(28);
char* shell = malloc(28);
strcpy(shell, "/bin/pwd");
scanf("%s", username);
system(shell);
```
*   **The Heap:** Unlike the previous challenge (Stack), this one uses `malloc`, placing data on the "Heap."
*   **The Flaw:** `scanf("%s", username)` does not limit how many characters the user can type. If the input exceeds 28 bytes, it will overflow into whatever is next in memory.

---

### **3. Addressing Your Technical Questions**

#### **Q1: Why did `nm` not show the names `username` or `shell`?**
When you ran `nm vuln (2)`, the output did not contain the words "username" or "shell." 
*   **Reason:** `nm` lists symbols (names) for **Global** variables or **Function** names stored in the binary. 
*   **Answer:** `username` and `shell` are **Local Variables** inside the `main` function. Furthermore, they are **Dynamic** (allocated at runtime on the Heap). Their names do not exist in the static symbol table of the compiled file; they only exist as memory addresses while the program is running.

#### **Q2: How did we find the "48-byte" Offset?**
You asked how I knew the magic number was 48. We used the **Address Leak** provided by the program:
*   `username at 0x...2a0`
*   `shell at 0x...2d0`

**The Math:**
1.  **Subtract the Hex addresses:** `0x2d0 - 0x2a0 = 0x30`.
2.  **Convert Hex to Decimal:** $3 \times 16^1 + 0 \times 16^0 = \mathbf{48}$.
3.  **Result:** This tells us that exactly 48 bytes of data exist between the start of the `username` buffer and the start of the `shell` buffer.

#### **Q3: Why 48 bytes if the code says `malloc(28)`?**
This is a common confusion. If we only reserved 28 bytes, why is the next variable 48 bytes away?
*   **Answer:** **Heap Metadata & Alignment.** 
    *   When you call `malloc(28)`, the system allocates the 28 bytes **plus** a "Header" (Metadata) used by the operating system to track the size of the memory chunk.
    *   Additionally, memory is "aligned" (usually to 8 or 16-byte boundaries) for CPU efficiency. 
    *   Therefore, 28 bytes + Metadata + Padding = 48 bytes of total distance.

#### **Q4: Why does `sh` give you a shell?**
*   **Answer:** `sh` is the name of the standard command-line interpreter in Linux. 
*   The program runs `system(shell)`. By overwriting the `shell` variable with the string `sh`, we force the program to execute `system("sh")`. This launches an interactive command prompt on the server, allowing us to type any command we want (like `ls` or `cat`).

#### **Q5: Why did we use `(python... ; cat) | nc`? (The Bridge)**
You noticed that without `cat`, the connection often closes.
*   **Reason:** When Python finishes sending the 48 'A's and the 'sh', it closes its output stream. The server sees this and closes the connection immediately.
*   **Answer:** The local command `; cat` keeps the "input pipe" open. It stays active and waits for **you** to type commands on your keyboard to send them to the server's newly opened shell.

---

### **4. Execution Trials & Results**

#### **The "Swap" Logic (Why order matters):**
We discussed what happens if the code order is changed.
*   **If `strcpy(shell, "uname")` happens AFTER your input:** The program will take your injected command, but then immediately overwrite it with "uname" before reaching the `system()` call. The "Last writer wins." In this challenge, the `scanf` was the last write, which is why it worked.

#### **Manual Exploitation (Successful):**
You successfully performed the exploit manually by typing the padding directly:
1.  **Input:** `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsh`
2.  **Server Response:** `Hello, AAA...Your shell is sh.`
3.  **Command Sent:** `ls` -> (Shows `flag.txt`)
4.  **Command Sent:** `cat flag.txt` -> (Reveals the Flag)

---

### **5. Final Flag**
**`picoCTF{us3rn4m3_2_sh3ll_a06d0fed}`**

---

### **Summary of Lessons Learned:**
1.  **Leaked Addresses are Gold:** They allow you to calculate exact distances in memory.
2.  **Heap vs. Stack:** Heap overflows involve `malloc` and often require bypassing metadata or padding.
3.  **Unsafe Functions:** `scanf("%s")` is just as dangerous as `strcpy` or `gets` because it never checks for buffer boundaries.
4.  **Payload Persistence:** Using a local "bridge" like `cat` is essential for interactive shells in netcat.ðŸš©ðŸš€
