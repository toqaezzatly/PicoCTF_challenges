
# **Challenge Writeup: Input Injection 1 (Pwn/Binary Exploitation)**

### **1. Challenge Overview**
*   **Target:** A C program that asks for a name, greets the user, and executes a system command (`uname`).
*   **Vulnerability:** Buffer Overflow due to the unsafe use of `strcpy`.

---

### **2. Trial 1: Command Injection (The First Guess)**
Since the challenge was named "Input Injection," I first tried standard command injection techniques to see if the input was being passed directly to a shell.
*   **Payloads tried:** `; ls`, `toqa && cat flag.txt`, `; cat flag.txt`
*   **Result:** **Failed.** 
*   **Reason:** The program was treating the input as a string and printing it inside a `printf` statement, not passing it directly to `system()`.

---

### **3. Trial 2: Fuzzing & Breaking Logic**
I sent a massive string of 'A' characters to see if I could crash the program or change its behavior.
*   **Observation:** When a long string of 'A's was sent, the word **"Linux"** (the output of the `uname` command) disappeared from the output.
*   **Conclusion:** This confirmed a **Buffer Overflow**. My input was "leaking" out of its assigned memory space and overwriting the variable that holds the command to be executed.

---

### **4. Technical Deep Dive (Source Code Analysis)**
The source code revealed the core flaw in the `fun` function:
```c
void fun(char *name, char *cmd) {
    char c[10];      // Destination for the command "uname"
    char buffer[10]; // Destination for the user's name
    strcpy(c, cmd);
    strcpy(buffer, name); // Vulnerable line
    system(c);
}
```
In memory (The Stack), `buffer` and `c` are placed right next to each other. Because `strcpy` does not check for size limits, writing more than 10 bytes into `buffer` will overflow into `c`.

---

### **5. Trial 3: Finding the Offset (The "Magic Number")**
I needed to find exactly how many bytes were required to reach the start of the `c` variable.
*   **Tried 32 bytes:** Overwrote too much.
*   **Tried 16 bytes:** Overwrote the command but was slightly off due to padding.
*   **Tried 10 bytes (The exact buffer size):** **SUCCESS!**

**Final Working Payload:**
```bash
python3 -c "import sys; sys.stdout.buffer.write(b'A'*10 + b'cat flag.txt\n')" | nc [IP] [PORT]
```
**Flag:** `picoCTF{0v3rfl0w_c0mm4nd_a52a04a8}`

---

### **6. The "Swap" Experiment (What if the code was different?)**
We tested a modified version of the code where the order of `strcpy` was swapped:
```c
// Modified Version
strcpy(buffer, name); // User input copied first
strcpy(c, cmd);      // Hardcoded "uname" copied second
```
#### **What happened?**
1.  **Injection Phase:** Our input `AAAAAAAAAAcat flag.txt` successfully overflowed and wrote `cat flag.txt` into the memory of `c`.
2.  **Overwrite Phase:** Immediately after, the program executed `strcpy(c, "uname")`. This line took the hardcoded `"uname"` and **overwrote our injected command**.
3.  **Result:** The program executed `system("uname")` and printed **Linux**. Our attack was "erased" by the program's own logic before it could reach the `system()` call.

#### **Conclusion of the experiment:** 
If the hardcoded copy happens **after** the user input copy, the injection is overwritten and fails. If it happens **before** (like in the original challenge), the user input has the "last word" and the exploit works.

---

### **Lessons Learned:**
1.  **Never use `strcpy`:** Always use `strncpy` or `fgets` to limit input size.
2.  **Memory Layout is Key:** Understanding how variables sit next to each other on the stack is the difference between a crash and a successful exploit.
3.  **Logic Flow Matters:** An exploit depends not just on *where* you write, but *when* you write it in the program's lifecycle.

---
**Ø¹Ø§Ø´ ÙŠØ§ Ø¨Ø·Ù„! Ø¯Ù‡ writeup Ø¨Ø±Ù†Ø³ ÙŠÙˆØ¶Ø­ Ø¥Ù†Ùƒ ÙØ§Ù‡Ù… ÙƒÙ„ ØªÙØµÙŠÙ„Ø© ØµØºÙŠØ±Ø© ÙˆÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„ØªØ­Ø¯ÙŠ.** ğŸš©ğŸš€
